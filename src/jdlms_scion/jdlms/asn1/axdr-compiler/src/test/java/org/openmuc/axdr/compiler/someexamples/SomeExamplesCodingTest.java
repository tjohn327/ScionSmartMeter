package org.openmuc.axdr.compiler.someexamples;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;

import java.io.ByteArrayInputStream;
import java.io.IOException;

import org.junit.Test;
import org.openmuc.axdr.compiler.someexamples.generated.MyChoice;
import org.openmuc.axdr.compiler.someexamples.generated.MyChoice2;
import org.openmuc.axdr.compiler.someexamples.generated.SequenceOfAll;
import org.openmuc.jasn1.ber.ReverseByteArrayOutputStream;
import org.openmuc.jdlms.internal.asn1.axdr.types.AxdrBitString;
import org.openmuc.jdlms.internal.asn1.axdr.types.AxdrBoolean;
import org.openmuc.jdlms.internal.asn1.axdr.types.AxdrEnum;
import org.openmuc.jdlms.internal.asn1.axdr.types.AxdrGeneralizedTime;
import org.openmuc.jdlms.internal.asn1.axdr.types.AxdrInteger;
import org.openmuc.jdlms.internal.asn1.axdr.types.AxdrNull;
import org.openmuc.jdlms.internal.asn1.axdr.types.AxdrOctetString;
import org.openmuc.jdlms.internal.asn1.axdr.types.AxdrVisibleString;

public class SomeExamplesCodingTest {
    @Test
    public void encodingDecoding() throws IOException {

        ReverseByteArrayOutputStream axdrOS = new ReverseByteArrayOutputStream(1000);

        MyChoice2 choice2 = new MyChoice2();
        choice2.setMyint(new AxdrInteger(4711));

        MyChoice choice1 = new MyChoice();
        choice1.setMyChoice2(choice2);

        SequenceOfAll seq = new SequenceOfAll(new AxdrInteger(-271864), new AxdrInteger(89), new AxdrBoolean(false),
                new AxdrBitString(new byte[] { 0x03 }, 8), new AxdrEnum(253),
                new AxdrGeneralizedTime(new byte[] { 12, 34 }), new AxdrNull(), new AxdrOctetString(new byte[0]),
                new AxdrVisibleString(new byte[] { 39, 32 }), new SequenceOfAll.SubSeqOfMySequence(), choice1);

        // Encode seq and check against pre-computed byte array
        byte[] expectedBytes = new byte[] { (byte) 0x83, (byte) 0xFB, (byte) 0xDA, (byte) 0X08, (byte) 0x81,
                (byte) 0x59, (byte) 0x00, (byte) 0x08, (byte) 0x03, (byte) 0xFD, (byte) 0x02, (byte) 0x0C, (byte) 0x22,
                (byte) 0x00, (byte) 0x02, (byte) 0x27, (byte) 0x20, (byte) 0x00, (byte) 0x01, (byte) 0x01, (byte) 0x82,
                (byte) 0x12, (byte) 0x67 };
        int length = seq.encode(axdrOS);

        assertEquals(expectedBytes.length, length);

        assertArrayEquals(expectedBytes, axdrOS.getArray());

        // Decode the generated byte array and check selected values
        ByteArrayInputStream bais = new ByteArrayInputStream(axdrOS.getArray());
        SequenceOfAll seq2 = new SequenceOfAll();

        seq2.decode(bais);
        assertEquals(seq.myBoolean.getValue(), seq2.myBoolean.getValue());
        assertEquals(seq.myInteger2.getValue(), seq2.myInteger2.getValue());
        assertEquals(seq.myChoice.getChoiceIndex(), seq2.myChoice.getChoiceIndex());
        assertEquals(seq.myChoice.myChoice2.myint.getValue(), seq2.myChoice.myChoice2.myint.getValue());

        // Encode the decoded PersonnelRecord again. The resulting byte array
        // must be identical to the first.
        ReverseByteArrayOutputStream axdrOS2 = new ReverseByteArrayOutputStream(1000);

        seq2.encode(axdrOS2);
        assertArrayEquals(axdrOS.getArray(), axdrOS2.getArray());
    }

}
